2.1-1:非降序INSERTION-SORT从第二个元素开始将该元素与它之前的元素进行比较，假如是最大值则不移动，否则移动
到合适的位置；

2.1-2:INSERTION_SORT 非升序C++实现：
#include<iostream>
#include<string>
#include<fstream>
#include<vector>
#include<sstream>
#include<map>
#include<set>

using namespace std;

int main(){
    vector<int> vec_int;
    for(int i = 0;i != 10;++i){
        vec_int.push_back(i);
    }
//    for(auto &i:vec_int){cout<<i<<endl;}
    for(int j = 1;j!=vec_int.size();j++){
        auto key = vec_int[j];
        auto i = j - 1;
        while(i >= 0 && vec_int[i]<key){
            vec_int[i+1] = vec_int[i];
            --i;
        }
        vec_int[i+1] = key;
    }
    for(auto &i:vec_int){cout<<i<<endl;}
    return 0;
}

2.1-3:
v=NIL
for i in range(len(A)):
    if v==A[i]:
        return i
for循环式满足初始化、保持、终止循环不变式的三个必要性质；

2.1-4:
dev = 0
for i in range(-1,-len(A)-1,-1):
    if A[i]+B[i]+dev == 0:
        C[i] = 0
    elif A[i]+B[i]+dev == 1:
        C[i] = 1
        dev = 0
    elif A[i] + B[i] + dev == 2:
        C[i] = 0
        dev = 1
    else:
        C[i] = 1
        dev = 1
C[0] = dev


2.2-1:theta(n^3)
2.2-2:选择算法
#include<iostream>
#include<string>
#include<fstream>
#include<vector>
#include<sstream>
#include<map>
#include<set>

using namespace std;

int main(){
    vector<int> a = {2,4,6,1,19,11,8};
    for(auto i = 0;i != a.size()-1;++i){
        auto j = i;
        auto minimize = a[i];
        auto minimize_num = i;
        while(j!=a.size()){
            if(a[j]<minimize){
            minimize = a[j];
            minimize_num = j;
            }
            ++j;
        }
        if(minimize_num!=i){swap(a[i], a[minimize_num]);}
        for(auto &m:a){cout<<m<<endl;}
        cout<<"-----------------------"<<endl;
    }
    return 0;
}
当我们进行了n-1次交换后，排在A[n]的一定是数组最大的元素;
best:theta(n^2);worst:theta(n^2);

2.2-3:为了体现出等可能性，至少要进行n次线性查找，平均和最坏需要theta(n^2)
2.2-4:添加判断语句，假如输入符合最好情况，直接输出；

2.3-5:#include<iostream>
#include<string>
#include<vector>

using namespace std;

int BINARY_SEARCH(vector<int> &A,int p,int f,int e){
    if (f<=e){
        int q = (f+e)/2;
        if (A[q]==p){return q;}
        else if (A[q]<p){return BINARY_SEARCH(A, p, q+1, e);}
        else if (A[q]>p){return BINARY_SEARCH(A, p, f, q-1);}
    }
    return -1;
}

int main() {
    vector<int> a = {1,2,3,4,5,6,7,8};
    cout<<BINARY_SEARCH(a, 3, 0, 7)<<endl;
    return 0;
}

2.3-6:不可以，INSERTION_SORT的5-7行实际上进行的主要工作是将当前数调换到合适的地方去；
即使使用二分查找，也不能使时间复杂度降到theta(nlgn)，也会是theta(n^2)；

2.3-7:使用merge_sort和binary_search即可在theta(nlgn)时间内完成；

思考题2-1:a.对于输入规模为n的数据，插入排序时间复杂度为theta(n^2);
对于输入规模为n/k*k的数据，插入排序时间复杂度为n/k*theta(k^2)=theta(nk);
b.合并n/k个子表->theta(lg(n/k))，总输入规模为n，所以总时间复杂度为theta(nlg(n/k))；
c.归并算法的时间复杂度为theta(nlgn),我们取k=lgn，则在忽略低次项后，修改后算法时间复杂度与归并算法
具有相同的运行时间；
d.选择小于lgn的k值；

2-2:
#include<iostream>
#include<vector>

using namespace std;

void BUBBLE_SORT(vector<int> &A,int q){
    for(auto i = 0;i < q;++i){
        for(auto j = A.size()-1;j != i;--j){
            if(A[j] < A[j-1]){swap(A[j], A[j-1]);}
        }
    }
}

int main(){
    vector<int> a = {3,4,5,6,7,8,1,2};
    BUBBLE_SORT(a, 7);
    for(auto &i:a){cout<<i<<endl;}
    return 0;
}
