2.1-1:非降序INSERTION-SORT从第二个元素开始将该元素与它之前的元素进行比较，假如是最大值则不移动，否则移动
到合适的位置；

2.1-2:INSERTION_SORT 非升序C++实现：
#include<iostream>
#include<string>
#include<fstream>
#include<vector>
#include<sstream>
#include<map>
#include<set>

using namespace std;

int main(){
    vector<int> vec_int;
    for(int i = 0;i != 10;++i){
        vec_int.push_back(i);
    }
//    for(auto &i:vec_int){cout<<i<<endl;}
    for(int j = 1;j!=vec_int.size();j++){
        auto key = vec_int[j];
        auto i = j - 1;
        while(i >= 0 && vec_int[i]<key){
            vec_int[i+1] = vec_int[i];
            --i;
        }
        vec_int[i+1] = key;
    }
    for(auto &i:vec_int){cout<<i<<endl;}
    return 0;
}

2.1-3:
v=NIL
for i in range(len(A)):
    if v==A[i]:
        return i
for循环式满足初始化、保持、终止循环不变式的三个必要性质；

2.1-4:
dev = 0
for i in range(-1,-len(A)-1,-1):
    if A[i]+B[i]+dev == 0:
        C[i] = 0
    elif A[i]+B[i]+dev == 1:
        C[i] = 1
        dev = 0
    elif A[i] + B[i] + dev == 2:
        C[i] = 0
        dev = 1
    else:
        C[i] = 1
        dev = 1
C[0] = dev


2.2-1:theta(n^3)
2.2-2:选择算法
#include<iostream>
#include<string>
#include<fstream>
#include<vector>
#include<sstream>
#include<map>
#include<set>

using namespace std;

int main(){
    vector<int> a = {2,4,6,1,19,11,8};
    for(auto i = 0;i != a.size()-1;++i){
        auto j = i;
        auto minimize = a[i];
        auto minimize_num = i;
        while(j!=a.size()){
            if(a[j]<minimize){
            minimize = a[j];
            minimize_num = j;
            }
            ++j;
        }
        if(minimize_num!=i){swap(a[i], a[minimize_num]);}
        for(auto &m:a){cout<<m<<endl;}
        cout<<"-----------------------"<<endl;
    }
    return 0;
}
当我们进行了n-1次交换后，排在A[n]的一定是数组最大的元素;
best:theta(n^2);worst:theta(n^2);

2.2-3:为了体现出等可能性，至少要进行n次线性查找，平均和最坏需要theta(n^2)
2.2-4:添加判断语句，假如输入符合最好情况，直接输出；
